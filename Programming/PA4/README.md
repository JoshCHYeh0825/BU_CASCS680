Fall 2025
Chih Han Yeh
CASCS680

PA4 - Shaded Rendering

# Primitive Definitions (Mesh Generation TODO1)

This assignment required moving from VBO-only rendering to EBO rendering. This means vertices are stored uniquely in `self.vertices`, and connectivity is defined via integer indices in `self.indices`.

## Generating Smooth Curvature Shapes - Sphere, Torus Ellipsoid

* These shapes are generated using a parametric grid approach (Stacks and Slices).
* Loops iterate through angles $\phi$ (latitude) and $\theta$ (longitude).
* **Seam Handling:** Vertices at the UV seam ($\theta = 0$ and $\theta = 2\pi$) are duplicated geometrically but assigned different Texture Coordinates ($u=0$ vs $u=1$) to ensure correct mapping.
* **Sphere:**

  * Generated using parametric equations, spherical coordinates where:

    $$
    x = rcos(\phi)cos(\theta), \quad y = rcos(\phi)sin(\theta), \quad z = rsin(\phi)
    $$
  * Normals are calculated as the normalized vector from the origin to the vertex position:

    $$
    n_x = cos(\phi)cos(\theta), \quad n_y = cos(\phi)sin(\theta), \quad n_z = sin(\phi)
    $$
* **Ellipsoid:**

  * Similar to the sphere but scaled by independent radii ($r_x, r_y, r_z$).
  * Their parametric equatsions are:
    $$
    x = r_xcos(\phi)cos(\theta), \quad y = r_ycos(\phi)sin(\theta), \quad z = r_zsin(\phi)
    $$
  * Normals are calculated using the gradient of the implicit ellipsoid equation:
    $$
    n_x = \frac{x}{r_x^2}, \quad n_y = \frac{y}{r_y^2}, \quad n_z = \frac{z}{r_z^2}
    $$
* **Torus:**

  * Generated by sweeping a circle (`R_{Tube}`) along a major circle ($R_{Axial}$). Both loops iterate $0$ to $2\pi$.
  * The implemented paramteric equations are:

    $$
    x = (R_{Axial} + R_{Tube}cos(\phi))cos(\theta), \quad y = (R_{Axial} + R_{Tube}cos(\phi))sin(\theta), \quad y = R_{Tube}sin(\phi)
    $$
  * The normal equations used are the same as the sphere.

## Primitives with Edges (Cylinder, Cube**Cylinder:**

* * Implemented through the use of sharpe edges (distinct normals for the caps vs. the walls).
  * The generation loop creates 4 distinct rings of vertices for every vertical slice:
    1. Top Cap Edge (Normal - Up: 0, 1, 0).
    2. Top Wall Edge (Normal: Outwards).
    3. Bottom Wall Edge (Normal: Outwards).
    4. Bottom Cap Edge (Normal - Down: 0, -1, 0).
  * Indices connect the centers to the caps (Triangle Fan) and the walls to each other (Triangle Strip/Quad logic).
* **Cube:**
  * Implemented with 24 distinct vertices, 4 per face.
  * Vertices are not shared between faces because each face requires a distinct normal vector

# Rendering & Shading Implementation

## Vertex & Normal Rendering (TODO 2)

Since normal vectors have components in the range $[-1, 1]$, they cannot be directly displayed as color (which expects $[0, 1]$).

* Mapping logic: `vec3 color = (normalize(vNormal) * 0.5) + 0.5;`
* This renders upward surfaces ($+Y$) as Green, rightward ($+X$) as Red, and forward ($+Z$) as Blue.

## Illumination Model (TODO 3)

Phong Reflection Model is implemented within Fragment Shader (`FragmentShader.glsl`). Lighting is calculated per-pixel rather than per vertex.

* **Ambient:**
  * Calculated as $k_a \times I_{scene}$.
  * A boost factor was applied to the ambient term to ensure shadows were visible and not pitch-black, matching the visual fidelity of the reference images.

    ```
    if(useAmbient){
                 finalColor = material.ambient.rgb * sceneAmbient * 4.0;
            }
    ```
* **Diffuse:**
  * Calculated using the dot product of the Normal ($N$) and Light Vector ($L$).
  * $$
    I_{diff} = k_d \times I_{light} \times \max(N \cdot L)
    $$
* **Specular:**
  * Calculated using the reflection vector $R$.
  * $$
    R = Reflect(-L, N)
    $$
  * $$
    I_{spec} = k_s \times I_{light} \times (V \cdot R)^{n_s}
    $$
  * The shininess exponent ($n_s$) controls the sharpness of the highlight.

## Light Sources (TODO 4)

The shader iterates through an array of `Light` structs, handling three distinct light types with specific physical properties:

1. **Infinite Light:**
   * Represents distant light sources (i.e the Sun).
   * The Light Vector $L$ is constant for all pixels and is calculated as $Normalized(-direction)$.
2. **Point Light:**
   * $L$ is calculated as the normalized vector from the Fragment Position to the Light Position.
     $$
     L = norm(L_{Direction} = P_{light} = v_{pos})
     $$
   * **Radial Attenuation:** Implemented using the polynomial inverse-square law provided in the lecture slides:
     $$
     f_{atten} = \frac{1}{a_0 + a_1 d + a_2 d^2}, \quad d = lenght(P_{light} - v_{pos})
     $$
3. **Spotlight:**
   * Inherits Point Light properties, with the addition of **Angular Attenuation**
   * Checks if the dot product between the light ray and the spotlight direction exceeds the cosine of the cutoff angle. If outside the cone, attenuation is set to 0.

     ```
     if (dot(-L, D) < cos(angleLimit)) {
         attenuation = 0.0;
     }
     ```

# Scenes & Materials (TODO 5)

Two custom scenes were created to demonstrate different material properties. Materials were defined using specific coefficients for Ambient ($k_a$), Diffuse ($k_d$), and Specular ($k_s$) reflection.

## Scene 2

* **Shapes:** Ellipsoid (Gold), Cylinder (Emerald), Torus (Silver).
* **Lighting:** Uses a **Spotlight** (overhead) and a Point light.
* **Materials:** Uses high shininess values ($n_s > 50$) and specular colors that match the surface color (characteristic of metals).

## Scene 3

* **Shapes:** Cube (Obsidian), Sphere (Pearl), Cylinder (Copper).
* **Lighting:** Uses an **Infinite Light** (Sunlight) required by the assignment.
* **Materials:** Uses lower shininess values and white specular highlights to simulate non-metallic/plastic surfaces.

# User Interaction

User controls were implemented in `Sketch.py` to allow runtime debugging and scene switching.

* **Scene Switching:** `Left` / `Right` Arrow Keys cycle between Scene 1, 2, and 3.
* **Rendering Mode:** `N` toggles Normal Visualization.
* **Component Toggling:**
  * `S`: Toggle Specular lighting.
  * `D`: Toggle Diffuse lighting.
  * `A`: Toggle Ambient lighting.
* **Light Toggling:** Keys `1`, `2`, `3` toggle individual lights in the current scene on/off.
