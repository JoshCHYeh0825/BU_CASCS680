
Fall 2025
Chih Han Yeh
CASCS680

PA4 - Shaded Rendering

# Primitive Definitions (Mesh Generation)

This assignment required moving from VBO-only rendering to EBO rendering. This means vertices are stored uniquely in `self.vertices`, and connectivity is defined via integer indices in `self.indices`.

## Generating Smooth Curvature Shapes - Sphere, Torus Ellipsoid

* These shapes are generated using a parametric grid approach (Stacks and Slices).
* Loops iterate through angles $\phi$ (latitude) and $\theta$ (longitude).
* **Seam Handling:** Vertices at the UV seam ($\theta = 0$ and $\theta = 2\pi$) are duplicated geometrically but assigned different Texture Coordinates ($u=0$ vs $u=1$) to ensure correct mapping.
* **Sphere:**

  * Generated using parametric equations, spherical coordinates where:

    $$
    x = rcos(\phi)cos(\theta), \quad y = rcos(\phi)sin(\theta), \quad z = rsin(\phi)
    $$
  * Normals are calculated as the normalized vector from the origin to the vertex position:

    $$
    n_x = cos(\phi)cos(\theta), \quad n_y = cos(\phi)sin(\theta), \quad n_z = sin(\phi)
    $$
* **Ellipsoid:**

  * Similar to the sphere but scaled by independent radii ($r_x, r_y, r_z$).
  * Their parametric equatsions are:
    * $x = r_xcos(\phi)cos(\theta)$, $y = r_ycos(\phi)sin(\theta)$, $z = r_zsin(\phi)$
  * **Normal Calculation:** Instead of a simple directional vector, the normals are calculated using the gradient of the implicit ellipsoid equation:
    $$
    n_x = \frac{x}{r_x^2}, \quad n_y = \frac{y}{r_y^2}, \quad n_z = \frac{z}{r_z^2}
    $$
* **Torus:**

  * Generated by sweeping a minor circle (Tube Radius) along a major circle (Axial Radius). Both loops iterate $0$ to $2\pi$.

## Sharp Shapes (Cylinder, Cube)

* **Cylinder:**
  * Implemented to support **Sharp Edges** (distinct normals for the caps vs. the walls).
  * The generation loop creates **4 distinct rings** of vertices for every vertical slice:
    1. Top Cap Edge (Normal: Up $\mathbf{0, 1, 0}$)
    2. Top Wall Edge (Normal: Outwards)
    3. Bottom Wall Edge (Normal: Outwards)
    4. Bottom Cap Edge (Normal: Down $\mathbf{0, -1, 0}$)
  * Indices connect the centers to the caps (Triangle Fan) and the walls to each other (Triangle Strip/Quad logic).
* **Cube:**
  * Implemented with **24 unique vertices** (4 per face).
  * Vertices are not shared between faces because each face requires a distinct normal vector (e.g., Front face normal is $\mathbf{0,0,1}$, Top face is $\mathbf{0,1,0}$).

# Rendering & Shading Implementation

## Vertex & Normal Rendering (TODO 2)

To verify geometry, I implemented a debug mode that visualizes surface normals. Since normal vectors have components in the range $[-1, 1]$, they cannot be directly displayed as color (which expects $[0, 1]$).

* **Mapping Logic:**
  $$
  \text{Color} = (\text{Normal} \times 0.5) + 0.5
  $$
* This renders upward surfaces ($+Y$) as Green, rightward ($+X$) as Red, and forward ($+Z$) as Blue.

## Illumination Model (TODO 3)

I implemented the **Phong Reflection Model** within the Fragment Shader (`FragmentShader.glsl`). Lighting is calculated per-pixel for smooth results.

* **Ambient:**
  * Calculated as $k_a \times I_{scene}$.
  * **Implementation Detail:** A boost factor was applied to the ambient term to ensure shadows were visible and not pitch-black, matching the visual fidelity of the reference images.
* **Diffuse (Lambertian):**
  * Calculated using the dot product of the Normal ($N$) and Light Vector ($L$).
  * $$
    I_{diff} = k_d \times I_{light} \times \max(N \cdot L, 0.0)
    $$
* **Specular (Phong):**
  * Calculated using the reflection vector $R$.
  * $$
    R = \text{reflect}(-L, N)
    $$
  * $$
    I_{spec} = k_s \times I_{light} \times (V \cdot R)^{n_s}
    $$
  * The shininess exponent ($n_s$) controls the sharpness of the highlight.

## Light Sources (TODO 4)

The shader iterates through an array of `Light` structs, handling three distinct light types with specific physical properties:

1. **Infinite Light:**
   * Represents distant sources like the sun.
   * The Light Vector $L$ is constant for all pixels and is calculated as $\text{normalize}(-\text{direction})$. No attenuation is applied.
2. **Point Light:**
   * $L$ is calculated as the normalized vector from the Fragment Position to the Light Position.
   * **Radial Attenuation:** Implemented using the polynomial inverse-square law provided in the lecture slides:
     $$
     f_{atten} = \frac{1}{a_0 + a_1 d + a_2 d^2}
     $$
3. **Spotlight:**
   * Inherits Point Light properties but adds  **Angular Attenuation** .
   * Checks if the dot product between the light ray and the spotlight direction exceeds the cosine of the cutoff angle. If outside the cone, attenuation is set to 0.

# Scenes & Materials (TODO 5)

Two custom scenes were created to demonstrate different material properties. Materials were defined using specific coefficients for Ambient ($k_a$), Diffuse ($k_d$), and Specular ($k_s$) reflection.

## Scene 2 (Metallic Theme)

* **Shapes:** Ellipsoid (Gold), Cylinder (Emerald), Torus (Silver).
* **Lighting:** Uses a **Spotlight** (overhead) and a Point light.
* **Materials:** Uses high shininess values ($n_s > 50$) and specular colors that match the surface color (characteristic of metals).

## Scene 3 (Matte Theme)

* **Shapes:** Cube (Obsidian), Sphere (Pearl), Cylinder (Copper).
* **Lighting:** Uses an **Infinite Light** (Sunlight) required by the assignment.
* **Materials:** Uses lower shininess values and white specular highlights to simulate non-metallic/plastic surfaces.

# User Interaction

User controls were implemented in `Sketch.py` to allow runtime debugging and scene switching.

* **Scene Switching:** `Left` / `Right` Arrow Keys cycle between Scene 1, 2, and 3.
* **Rendering Mode:** `N` toggles Normal Visualization.
* **Component Toggling:**
  * `S`: Toggle Specular lighting.
  * `D`: Toggle Diffuse lighting.
  * `A`: Toggle Ambient lighting.
* **Light Toggling:** Keys `1`, `2`, `3` toggle individual lights in the current scene on/off.
